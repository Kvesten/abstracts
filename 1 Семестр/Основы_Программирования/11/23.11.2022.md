## Перегрузка функций.

Использование нескольких функций с одним и тем-же именем, но с различными типами параметров называется перегрузкой функции.

Цель перегрузки состоит в том, чтобы функция с одним и тем же именем по раному выполнялась и возвращала разные значения при обращении к ней с различными типами и различным числом фактическим параметров.

Для обеспечения перегрузки необходимо для каждой перегруженой функции определить возвращаемое значение и передаваемые параметры так, чтобы каждая перегруженая функции отличалась от другой функции с тем же именем. 

Компилятор определяет какую функцию выбрать по типу и количеству фактических параметров.

```c
int max(int a, int b);
float max(float a, float b);
char* max(char *a, char *b);
```

## Правило описания перегруженых функций
1. Перегруженые функции должны находиться в одной области видимости.
2. перегруженые функции могут иметь параметры по умолчанию, при этом, значение одного и того же параметра  в разных функция должны совподать. В разных вариантах перегруженых функций может быть разное кол-во параметров по-умолчанию.
3. Функции не могут быть перегружены, если описание их параметров отличаются только модификатором ```const``` или наличием ссылки. Например:
```c
int f(int a, int b);
int f(int a, int &b);
```
Вышеприведённые функции не являются перегружеными, так как компилятор не сможет определить какая из функций вызывается, нет синтаксических отличий между вызовом функци, которая передаёт параметр по значению и вызовом функции, которая передаёт параметр по ссылке.

```c++
float f(float i);
double f(double i);

float x = 10.99;
double y = 10.99;

f(x) // Ok
f(y) // Ok

f(10) // Not Ok, неопределённость, что вызывать, функции с float  или double?
```

## Шаблоны функций

Шаблоны используются для того, чтобы автоматизировать создание функций, обрабатывающих разнотипные данные. Например алгоритм сортировки можно использовать для массивов различных типов.

При **перегрузке функций** для каждого используемого типа определяется своя функция.

**Шаблон функции** определяется один раз, но определение параметризуется. Т.е. тип данных определяется как параметр шаблона.

## Формат шаблона.

```c++
template <class имя типа [, class имя типа]>
заголовок функции
    {тело функции};

template <class имя_типа>
заголовок функции
    {тело функции};

template <typename имя_типа>
заголовок функции
    {тело функции};

```

шаблон семейства функций состоит из двух частей 
1. Загаловка шаблона(template <Список параметров шаблона>).
2. Определение функции, в которой вместо типа возвращаемого значения и/или типа параметров записывается имя типа, определённое в загаловке шаблона.

Пример:

```c++
template <class type> // type - имя параметризируемого типа.

type abs(type) {
    if(x < 0) return -x;
    else return x;
}
```

шаблон служит для автоматического формирования конкретных описаний функций, которые компилятор встречает в программе.

Например, если вызов функции определяется как ```abs(-1.5)```, то компилятор сформирует определение функции ```double abs(double x)```.

```c++
template <class T>

void change(T *x, T *y) {
    T z = *x;
    *x = *y;
    *y = z;
}
```


```c++
long k = 10, l = 5;
change(&k, &l)
```

компилятор сформирует определение.

```c++
void change(long *x, long *y) {
    long z = *x;
    *x = *y;
    *y = *z;
}
```

Пример:

```c++
template<class Data>

Data& rmax(int n, Data a[]) {
    int im = 0;
    for(int i = 0; i < n; i++)
        if(a[im] < a[i]) im = i;
    return a[im];
}

void main() {
    int n = 5;
    int x[] = {1, 2, 3 ,4 ,5 };
    cout << rmax(n, x) << endl;

    float y[] = {10.4, 20.2, 30.6, 15.5};
    cout << rmax (4, y) << endl; 
}
```


## Основные свойства параметров шаблонов функций.

1. Имена параметров должны быть уникальными во всём определении шаблона.
2. Список параметров шаблона не может быть пустым.
3. В списке параметров шаблона может быть несколько параметров, каждый из них должен начинаться со слова ```class```.

## Указатель на функцию.
Каждая функция характеризуется типом возвращаемого значения и списком типов её параметров. Если имя функции использовать без последующих скобок и параметров, то оно будет выступать в качестве указателя на эту функцию. И значением будет адресс размещения функции в памяти. 

Это значение можно будет присвоить другому указателю и тогда этот новый указатель можно будет использовать для вызова функции.

Указатель на функцию определяется следующим образом.

```c++
_t(*pointer_name)(params);

int f1(char c) {};
int (*ptrf1)(char);

char *f2(int k, char c);
char* (*ptrf2)(int, char);
```
$$\forall XY \exists \lambda$$
в определении указателя количество и тип параметров должны совпадать. 