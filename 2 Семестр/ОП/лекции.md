#  Списки

Списком называется упорядоченное множество состоящее из переменного числа элементов, к которым можно применить в котором применимы операции включения\исключения

- Список отражающий отношения соседства между элементами называется линейным.

- Длинна списка равна числу элементов содержащихся в списке

- Список нулевой длинны называется пустым списком.

Для связывания элементов в списке используют систему указателей. 

В минимальном случае любой элемент линейного списка имеет один указатель или является указателем null, что интерпретируется как конец списка.

Структура элементами которого являются записи одним и тем же форматом связанныe друго-с-другом с помощью указателей хранящихся в самих элементах называется связаным списком.

В связном списке элементы линейно упорядоченны, но порядок определяется не номерами, как в массиве, а указателями.

Каждый список имеет особый элемент называемый указателем начала списка(головой списка), который обычно по содержанию отличен от остальных элементов. 

В поле указателя последнего элемента списка находятся специальный признак (null) свидетельствующий о конце списка.

## Однонаправленные списки
**Однонаправленный список** - это структура данных, представляющая собой последовательность элементов, в каждом из которых, хранится
- значение
- указатель на следующий элемент


```
ptr_on_first -> ptr -> ptr -> NULL
------------    ---    ---
content         ctn     ctn
```

Описание простейшего элемента такого списка выглядит так:

```c++
struct type_name {
    contnt_field;
    ptr_field;
};
```

Где content_field - это поле любого стандартного или ранее объявленного типа.

И ptr_field - это указатель на объект того же типа, что и определяемая структура.

### Например

```cpp
struct Node {
    int key;
    Node* next;
};

struct Point {
    char* name;
    int age;
    Point* next;
};
```

Основные операции, осуществляемые с однонаправленными списками.

- Создание списка
- Просмотр списка
- Вставка элементов в список
- Удаление элемента из списка
- Поиск элемента
- Проверка пустоты списка
- Удаление списка

Для описания алгоритмов этих основных операций будем использовать следующее объявление:

```cpp
struct List{
    int content;
    List* next;
};
```

При работе с однонаправленным списком необходимо обеспечить позиционирование какого-либо Указателя на первый Элемент. В противном случае часть ил весь список будет недоступен.

## Создание однонаправленного списка.

```cpp
List *head = NULL;
int x;
cout << "Введите элементы (пирзнак завершения 0)" << endl;

cin >> x;

if(x != 0) {
    head = new List;
    head->content = x;
    head->next = NULL;
    cin >> x;
    List *p = head;

    while(x != 0) {
        List *r = new List;
        r->content =  x;
        r->next = NULL;
        p->next = r;
        p = r;
        cin >> x;
    }
}
```


## Просмотор списка
```cpp
List* p;

while(p != NULL) {
    manipulate(p->content);
    p = p->next;
}
```

## Вставка элементов списка
---
В динамические структуры данных легко добавлять новые элементы, так как, для этого достаточно значения адрессных полей. Вставка первых и последующих элементов списка отличаются друг-от-друга

```cpp
/*Включение элемента в список после элемента со ссылкой p*/

List *r = new List;
r->content = data;
r->next = p->next;
p->next = r;
p = r;
```

## Удаление элемента.
---


```cpp
if(p->next != NULL) {
    List *r = p->next;

    p->next = r->next; 
    delete r;
}

```


```cpp
p=head;
while(p!=NULL) {
    List *r = p;
    p = p->next;
    delete r;
}
```
Рекурсивный метод

```cpp
void Delete_List(List* head) {
    if (head != NULL) {
        Delete_List(head->next);
        delete head;
    }
}
```

## Примеры
---

Найти сумму четных элементов чисел расположенных после нечётных.

```cpp
p = head;
while(p->next != NULL) {
    if(p->info % 2 != 0 && p->next->info % 2 == 0)
        sum += p->next->info;
    p = p->next;

}

cout << "SUM: " << sum << endl;
```

2. Дан однонаправленный список целых чисел. Вставить поcле каждого нечётного элемента заданное число x:

```cpp
int x;
cin >> x;

p = head;

while(p!=NULL) {
    if(p->info % 2 != 0) {
        List* r = new List;
        r->info = x;
        r->next=p->next;
        p->next = r;
        p = r;
    }
    p = p->next;
}
```

3. Дан однонаправленный список целых чисел. Если список не знакочередующийся, то удалить все нечётные элементы списка.


# Двухнаправленый список список.


## Удаление
```cc
if(p!=NULL && p->info == cond) {
    tmp = p;
    p = p->prev;
    if(p!=NULL) p->next = NULL;
    
    delete tmp;
}
```

## Вставка
```cc
p = head;
while(p != NULL) {
    if(p->info == cond) {
        DoubleList* r = new DoubleList;
        r->info = /*insert*/;
        r->next = p->next;
        r->prev = p;
        p->next = r;
        if(r->next != NULL) r->next->prev = r;

        p = r;
    }
    p = p->next;
}
```

## Проверка пустоты
```cc
bool EmptyDList(DoubleList* head) {
    if(head != NULL) return false;
    return true;
}
```

## Освобождение памяти
```cc
void DeleteDList(DoubleList* head) {
    if(haed != NULL) {
        DeleteDList(head->next);
        delete head;
    }
}
```

## Поиск элемента в двунаправленном списке.
Поиск элементов в двунаправленном может осуществляться несколькими способами.

1. Просматривая элементы от начала к концу списка
2. Просматривая элементы от конца к началу списка
3. Просматривая элементы в обоих направлениях одновременно
   
### Пример.
$X_1*X_n+X_2*X_{n-1}+...$


### Решение
```cc
struct DoubleList {
    int info;
    DoubleList* next, *prev;
};

DoubleList* head = null, *p, *r;

int x, n;
cin >> n;
cin >> x;
head = new DoubleList;
head->info = x;
head->next = NULL;
head->prev = NULL;

p=head;
for(int i = 2; i<=n; i++) {
    cin >> x;
    r = new DoubleList;
    r->info = x;
    r->next = NULL;
    r->prev = p;
    p->next = r;
    p = r;
}

int sum = 0;
while(p != NULL) {
    sum += p->info * r->info;
    cout << p->info*r->info << "\t";
    p = p->next;
    r = r->prev;
}
cout << sum;
```

# Рекурсия в списках

## Сумма кратных пяти списка рекурсивно
```cc
int sum(List *p) {
    if(p==NULL) return 0;
    if(p->info % 5 == 0) return sum(p->next) + p->info;
    return sum(p->next);
}
```

## Увелиить кратные трём элементы списка
```cc
void mutate(List*& p) {
    if(p != NULL) {
        if(p->info % 3 == 0) p->info *= 2;
        mutate(p->next);
    }
}
```

## Каждому чётному элементу присвоить -5
```cc
void InsertElement(int data, List*& p) {
    List* r = new List;
    r->info = data;
    r->next = p->next;
    p->next = r;
    p = r;                                                                                              
}
```

В первом случае - *p это указатель на тип данных List.
Во втором случае - *&p это ссылка на указатель на List.

А значит, поменяв содержимое указателя фактически меняется содержимое указателя в вызовшем эту функцию в коде.


# Двунаправленные кольцевые списки
Расмотренных видов связных списков - является **кольцевой список**, который может быть организован на основе как однонаправленного, так и двунаправленного списка.

В однонаправленном списке указатель последнего элемента должен указывать на первый элемент этого же списка.

**Графически однонаправленный кольцевой** список можно представить следующим образом: 

```
->next->next->
  info  info
```

В **двунаправленном списке** в первом и последнем эл-те соответствующий указатели переопределяются

**Графически двунаправленный  кольцевой** список можно представить след. обрпзом

Тут должна быть картинка...

Базовая статическая структура описывающая эл-т кольцевого списка аналогично структуре рассмотренной ранее при описании однонаправленного или двунаправленного списка.

Однако просмотр кольцевого списка способом описанным ранее в ввиду отсутствия указателей со значением NULL влечёт за собой попадание в бесконечный цикл.

Формально в кольцевом списке **нет понятия головы**, но рекомендуется выделять некоторый эл-т и прининмать его за голову списка.

## Построение двунаправленного кольцевого списка
```cc
DoubleList* construct() {
    int x;
    cin >> x;
    if(x != 0 ) {
        head = new DoubleList;
        head->info = x;
        head->next = head;
        head->prev = head;

        cin >> x;
        DoubleList* p = head;
        while(x != 0) {
            DoubleList* r = new DoubleList;
            r->info = x;
            r->next = head; // <<
            r->prev  = p;
            p->next = r;
            p = r;
            cin >> x;
        }

        head->prev = p;
        // p->next = head; но нужно удалить место, где помечено <<
        return head;
    }
}
```

## Обработка кольцевого списка
```cc
void mut() {
    DoubleList *p = head;
    while(p->next != head) {
        // Обработка p->info;
        p = p->next;
    }
    // Обработка последнего элемента, т.к. он не 
    //обрабатывается из-за условия в while
}
```

```cc
void mut() {
    DoubleList *p = head;
    do {
        // Обработка p->info;
        p = p->next;
    } while(p->next != head);
}
```

# Стек
В списках доступ к элементам происходит по средствам адресации, при этом, доступ к отдельным элементам неограничен существуют списковые структуры данных, в которых  имеются ограничения доступа к элементам.

Одним из представителей таких структур является **Стек**

Определение: **Стек** - это структура данных, в которой новый элемент всегда записывается в её начало(верхушку). И очередной читаемый элемент также всегда выбирается из её начала.

В стеках используется метод доступа к элементам *Lifo* - Последний пришёл первый ушёл.

При выборе элемента из стека он удаляется, а находящиеся под ним становятся новой верхушкой стека.

На стеках определены следующие операции.
- Создать стек
- Добавить элемент
- Извлечь элемент
- Проверка на пустоту
  
Стек как абстрактное хранилище данных имеет бесконечный объём, однако на практике имеющиеся в распоряжении программы объём памяти всегда конечен. И следовательно можно использовать только стек ограниченного объёма. Так называемый **Ограниченный стек**.

Очевидно, что для любого стека операции извлечь из стека определена только тогда, когда стек не пуст, а операция добавить в стек является частичной для ограниченного стека.

Ситуация, в которой делается попытка добавить в ограниченный стек элемент, а имеющаяся память уже исчерпана называется операцией **переполнения** .

# Реализация стека фиксированного размера на основе одномерного массива.

```c
#define STACK_MAX_SIZE 1000

typedef int T;

struct Stack_t {
    T data[STACK_MAX_SIZE];
    size_t size;
};
```

```c
bool empty(Stack_t* stack) {
    return (stack->size == 0);
}

bool full(Stack_t* stack) {
    return (stack->size >= STACK_MAX_SIZE);
}

void push(Stack_t* stack, const T value) {
    stack->data[stack->size] = value;
    ++stack->size;
}

T pop(Stack_t* stack) {
    --stack->size;
    return stack->data[stack->size];
}
```

```c++
int main() {
    Stack_t stack;
    stack.size = 0;

    for(int i = 0; i < 30; i++) {
        if(!full(&stack)) push(&stack, i);
        else {
            cout << "Stack overflow" << endl;
            break;
        }
    }

    if(!empty(&stack)) {
        cout << pop(&stack);
        cout << pop(&stack);
        cout << pop(&stack);
    }

    return 0;
}
```

# Реализация стека на основе однонаправленного списка.
```c++
struct Stack {
    int info;
    Stack *next;
};

Stack* CreateStack() {
    return NULL;
}

bool IsEmptyStack(Stack * top) {
    return top == NULL;
}

void Stack(int data, Stack *&top) {
    Stack *r = new Stack;
    r->info = data;
    r->next = top;
    top = r;
}
```

```c++
int pop(Stack *&top) {
    if(!IsEmptyStack(top)) {
        Stack *r = top;
        int x = r->info;
        top = top->next;
        delete r;
        return x;
    }
    return NAN;
}
```

```c++
void PrintStack(Stack *&top) {
    while(!IsEmptyStack(top))
        cout << StackPop(top) << '\t';
}
```

```c++
void DeleteStack(Stack *&top) {
    while(!IsEmptyStack(top))
         StackPop(top);
}
```

```c++
int main() {
    Stack *stack;
    stack = createStack();

    for(int i = 0; i < 30; i++)
        StackPush(i, stack);

    cout << "top = " << StackPop(stack) << endl;
    cout << "all elements = ";
    PrintStack(stack);
    DeleteStack(stack);

    return 0;
}
```

Вводится последовательность )( ][ определим правильную последовательность по след. правилу...(IMG)

```c++
int main() {
    Stack *top = CreateStack();
    bool flag = true;
    for(char x = getchar(); x!='\n'; x=getchar()) {
            switch(x) {
                case '(':
                case '[': {StackPush(x, top); break;}
                case ')': {flag = flag && (StackPop(top) == '('); break;}
                case ']': {flag = flag && (StackPop(top) == '['; break;)}    
                default: flag = false;
            }
    }
    flag = flag && IsEmptyStack(top);
    if(flag) cout << "Yes";
    else cout << "NET";

    DeleteStack(top);

        
    return 0;
}
```

# Очередь
## def: Очередь
Это структура данных, представляющая собой последовательность элементов образованную в порядке их поступления.

Каждый новый элемент размещается в конце очереди, а элемент стоящий в начале очереди выбирается из неё первым.

В очереди используется принцип доступа к элементам **FIFO**.

В очереди доступны два элемента - начало и конец очереди.

Графически очередь можно представить так:
[img]

## Основные операции производимые с очередью:
1. Создание
2. Печать/Просмотр
3. Добавление элементов в конец
4. Извлечение элемента из начала
5. Проверка пустоты
6. Очистка очереди

## Реализация очереди фиксированного размена на основе одномерного массива

```c++
#define QUEUE_MAX_SIZE const
typedef int T;

struct Queue {
    T data[QUEUE_MAX_SIZE];
    int head = 0;
    int tail = 0;
};

void push(Queue* queue, const T value) {
    queue->data[queue->tail] = vail;
    queue->tail++;
}

T pop(Queue* queue) {
    queue->head++;
    return queue->data[queue->head - 1];
}

bool empty(Queue* queue) {
    return queue->head == queue->tail;
}

bool full(Queue* queue) {
    return queue->tail >= QUEUE_MAX_SIZE;
}
```

**Alberto Balsalm - Aphex Twin.**

```c++
int main() {
    Quque queue;
    for(int i = 0; i<30; i++)
        if(!full(&queue))
            push(&queue, i);
        else {
            cout << "queue is full" << endl;
            break;
        }    
    cout << pop(&queue);
    cout << pop(&queue);

    if(!empty(&queue)) cout << pop(&queue);

    return 0;
}
```

## Реализация на основе списка.

# Деревья
ВСТАВИТЬ КАРТИНКУ СМЕШНО МУДРОЕ ДЕРЕВО СРОЧНО

Дерево является - одним из частных случаев графа и одной из наиболее распространённых структур данных в программировании.

Древовидная модель эффективна для представления динамических данных с целью быстрого поиска информации.

## def: Дерево
это структура данных представляющая собой совокупность элементов и отношений образующих иерархическую структуру этих элементов.

Каждый элемент дерева называется Node/Нода/Вершина/Узел вершины дерева соеденены направленными дугами, которые называют ветвями дерева.
Начальный узел дерева называют корнем дерева и ему соответствует нулевой уровень.

Листья дерева - это вершины, в которые входят одна ветвь и не выходит ни одной ветви.

Каждое дерево обладает следующими свойствами.
1. Существует узел в которой не входит ни одной дуги
2. В каждую вершину кроме корня входит одна дуга
Все вершины, в которые входят ветви исходящие из одной общей вершины, называются потомками, а сама вершина предком, уровень потомка на единицу превосходит уровень его предка. Корень дерева не имеет предка, а листья не имеет потомка.

Глубина дерева определяется кооличеством уровней на которых распологаются его вершины. Высота пустого дерева равна нулю, высота дерева из одного корня равна единице

## Поддерево
---
**def**


Часть древовидной структуры данных,* которая может быть представлена в виде отдельного дерева. 


**def:**


**Степенью вершины** называется количество дуг, которые из неё выходят.

**def: Степень дерева**


равна максимальной степени вершины, вхоядщей в дерево, при этом *листья имею степень нуль*

По величене степени деревья различают на:

1. Двоичные(Бинарные) - Степень дерева <= 2
2. Сильно-ветвящиеся - Степень дерева - произвольная.

## **Уподяроченное дерево**
**def:**


Это дерево у которого ветви исзодящие из каждой вершины упорядочены по определённому критерию.

*Деревья являются рекурсивной структурой, в которой каждый элемент является либо пустой структурой, либо элементом с которым связана конечное число поддеревьев*

> Действия с рекурсивными структурами удобнее всего описываются с помощью рекурсивных алгоритмов.

Для того, чтобы выполнить отдельную операцию над всеми вершинами дерева необходимо все его вершины посетить. Такая задача называется **обход дерева**.

## **Обход дерева**
**def:**

Упорядоченная последовательность вершин дерева в которой каждая вершина встречается только один разю

Выделим три наиболее частых использования способа обхода дерева: 
1. **Прямой**
2. **Симметричный**
3. **Обратный**

Существует большое разнообразие древовидных структур данных:

1. **Бинарные деревья**
2. **Красно-чёрные деревья**
3. **B Tree**
4. **AVL Tree**
5. **Матричные деревья**
6. **Смешанные деревья**
7. ...

# Бинарные деревья
---

**def:**

**Бинарное(двоичное) дерево** - это динамическая структура данных, представляющих собой дерево, в которой каждая вершина имеет не более двух потомков. Каждая вершина бинарного дерева является структурой, состоящей из 4-ёх видов полей.

1. Информационное поле.
2. Служебное поле.(Их может быть несколько или вообще ни одного).
3. Указатель на левое поддерево.
4. Указатель на правое поддерево.

По степени вершин бинарные деревья делятся на:
1. Строгие. (Вершины дерева имеют степень 0 или 2)
2.  Не строгие. (Вершины дерева имеют степень 0 и 1 или 2)

В общем случае на k-ом уровне бинарного дерева может быть 

Бинарное дерево - **Полное**, если оно содержит только полностью заполненные уровни. Иначе оно **Неполное**.

Дерево - **Сбалансированно**, если длинны всех путей от корня к внешним вершинам равны между собой.

Дерево - **Почти сбалансированно**, если длинны всех путей от корня к внешним вершинам отличаются не более чем на единицу.

> Дерево может выродиться в список.

## Двоичное дерево поиска
**def:**

Бинарное дерево обладающее дополнительными свойствами. Значение *левого* потомка **меньше** значения левого, а значение *правого* потомка **больше** значения предка для каждого узла дерева.

> При каждой операции вставки нового или удаления существующего узла порядок элементов в дереве сохраняется.

Для моделирования деревьев определим следующий тип(Структуру): 

```cpp
struct Tree {
    int info;
    Tree *left;
    Tree *right;
};
```

Опишем функцию, в которой уже к имеющимуся дереву двоичного поиска добавляют новый узел так, чтобы  вновь образованное дерево также являлось двоичным деревом поиска.

### Функция добавления

```cpp
void addNode(Tree *root, int data) {
    if(data < root->info) {
        if(root->left == NULL) {
            Tree *r;
            r = new Tree;
            r->info = data;
            r->left = NULL;
            r->right = NULL;

            root->left = r;
        } else addNode(root->left, data);
    } else {
        if(root->right=NULL) {
            Tree *r;
            r = new Tree;
            r->info = data;
            r->left = NULL;
            r->right = NULL;
            root->right = r;
        } else addNode(root->right, data);
    }
}
```


### Построение дерева
```cpp
    // Построение дерева.
Tree* construct() {
    int x;
    Tree *root = new Tree;
    cin >> x;
    root->info = x;
    root->left = NULL;
    root->right = NULL;

    cin >> x;
    while(x != 0) {
        addNode(root, x);
        cin >> x;
    }

    /* for(cin>>x; x!=0; cin>>x)
    /       addNode(root,x);   
    */

    return root;
}
```

### Основные обходы деревьев
1. pre-order/NLR/Прямой/Префиксный
Вначале обрабатывается вершина, затем левое, затем правое поддерево
2. Инфиксный/LNR
3. Обратный/Кольцевой/Постфиксный/LRN/DPR

Приведём алгоритмы обхода дерева на примере вывода информационных полей.
   
### Вывод дерева NLR
```cpp
void print_nlr(Tree* root) {
    if(root != NULL) {
        cout << root->info <<" ";
        print_nlr(root->left);
        print_nlr(root->right);
    }
} 
```

### Вывод дерева симметричный LNR
```cpp
void print_lnr(Tree* root) {
    // Выведет в порядке возрастания.
    if(root != NULL) {
        print_lnr(root->left);
        cout << root->info <<" ";
        print_lnr(root->right);
    }
}  
```
### Вывод дерева обратным обходом LRN
```cpp
void print_lrn(Tree* root) {
    // Выведет в порядке возрастания.
    if(root != NULL) {
        print_lrn(root->left);
        print_lrn(root->right);
        cout << root->info <<"  ";
    }
}  
```

Согласно определению дерева все вершины храняться в динамической памяти и следовательно необходимо определить алгоритм её освобождения. Для этого удобно использовать орбатный обход дерева (LRN)

### Освобождение памяти LRN
```cpp
void Destroy(Tree* root) {
    if(root == NULL)
        return;
    Destroy(root->left);
    Destroy(root->right);
    delete root;
}
```



$\forall x, y \in L$

---
Коммичено до сюдова


## Примеры

**Пример 1**. Дано дерево двоичного поиска. Найти сумму четных элементов дерева.

```cpp
int Sum(Tree* t) {
    if(t == NULL)
        return NULL;
    else 
        if (t->info %  2 == 0)
            return t->info + Sum(t->left) +Sum(t->right);
        else return Sum(t->left) +Sum(t->right);;
}

```

**Пример 2**. Дано дерево двоичного поиска. Найти сумму элементов дерева, являющихся листьями.

```cpp
int Sum(Tree* t) {
    if(t==NULL) return 0;
    else if(t->right == NULL && t->left == NULL) 
        return t->info;
    return Sum(t->left) + Sum(t->right);
}
```

**Пример 3**. Дано дерево двоичного поиска найти максимальный элемент на заданном уровне.

```cpp
#include "algorithm"

int MaxByLevel(Tree *t, int currentLevel, int Level) {
    if(t == NULL) return -INFINITY;
    if(currentLevel == Level) return t->info;

    return max(
        MaxByLevel(t->left, currentLevel + 1, Level),
        MaxByLevel(t->right, currentLevel + 1, Level)
    );
}
```

*Второй вариант решения*
```cpp
struct Tree {
    int info;
    int level;
    Tree *left;
    Tree *right;
};
// Логично, что при построении уровень будет root->lvl + 1


int MaxByLevel(Tree *t, int level) {
    if(t==NULL) return -INFINITY;
    if(t->level == Level) return t->info;

    return max(
        MaxByLevel(t->left, level),
        MaxByLevel(t->right, level),
    );
}
```

## Удаление узла дерева
---

Существуют 3 возможных ситуации:
1. **У вершины нет потомков**. В этом случае удаляется лист,а его родитель обнуляет указатель на него.
2. **У вершины 1 потомок**. В этом случае вершина заменяется своим потомком.
3. **У вершины оба потомка**. В этом случае вершину не удаляем, а заменяем её значение на максимум левого поддерева. После этого удаляем максимум левого поддерева. Максимум левого поддерева имеет не более одного потомка, поэтому его удаление осуществить легко. Аналогично можно заменить минимумом из правого поддерева.

```cpp
Tree* DeleteNode(Tree* t, int data) {
    if (t==NULL) return t;

    if(data == t->info) {
        Tree* tmp;
        if(t->right == NULL)
            tmp = tmp->left;
        else {
            Tree* ptr = t->right;
            if(ptr->left = NULL) {
                ptr->left = t->left;
                tmp = ptr;
            } else {
                Tree *pmin = ptr->left;
                while(pmin->left != NULL) {
                    ptr = pmin;
                    pmin = ptr->left;
                }
                ptr->left = pmin->right;
                pmin->left = t->left;
                pmin->right = t->right;
                tmp = pmin;
            }
        }

        delete t;
        return tmp;
    }
    else if(data < t->info)
        t->left = DeleteNode(t->left, data);
    else
        t->right = DeleteNode(r->right, data);
    return t;
}
```

# Потоки ввода/вывода
---

Функционал потоков ввода/вывода не определён как часть языка С++, а предоставляется стандартной библиотекой С++ и находится в пространстве имён std.

**Def:**

**Поток** - последовательность символов к которым можно получить доступ. Со временем поток может производить или потреблять потенциально неограниченные объёмы данных.

Рассмотрим 2 типа вопросов.

1


Поток ввода(входной поток) используется для хранения данных полученных от источника данных(Клавиатура, файл, сеть, ...).

Например пользователь может нажать клавишу в то время, когда программа не ожидает ввода. Вместо игнорирования нажатия клавиши данные помещаются в обходной поток, где ожидают ответа от программы.

2

Поток вывода используется для хранения данных придостовляемых конкретному потребителю данных (Монитор, файл, сеть, ...)

При записи данных на устройство вывода  это устройство может быть не готово принять данные немедленно. 

Например принтер может прогреваться, когда программа уже записывает данные в выходной поток, где данные будут находиться до тех пор, пока принтер не начнёт их использовать.

Некоторые устройства такие как файлы и сети могут быть источниками как ввода, так и вывода данных.

## Ввод/ввывод в C++

Класс **istream** используется для работы с вхожными потоками.

Оператор извлечения(>>) используется для извлечения данных из потока.

Класс **ostream** используется для работы с выходными потоками.

Оператор вставки(>>) используется для помещения данных в поток.

Класс **iostream** может обрабатывать как ввод, так и вывод данных, что позволяет осуществлять двунаправленный ввод вывод.

## Стандартные потоки в С++
---

**Стандартный поток** - это предварительно подключеный поток, который предоставляется программе её окружением.

Язык C++ поставляется с четыремя предварительно определёнными стандартными объектами потоков, которые можно использовать:

* cin - Это класс, связанный со стандартным вводом(Обычно это клавиатура)
* cout - Это класс, связанный со стандартным выводом(Монитор)
* cerr - Это класс, связанный со стандартной ошибкой, обеспечивающий небуферизированный вывод
* clog - Это класс, связанный со стандартной ошибкой, обеспечивающий буферизированный вывод.

> Небуферизированный вывод обычно обрабатывается сразу же, тогда как буферизированный обычно сохраняется и выводится как блок.

Весь функционал объектов, которые работают с потоками ввода/ввывод находится в пространстве имён std - это означает, что нужно добавлять префикс std:: ко всем объектам и функциям ввода/вывода, либо использовать using namespace std;