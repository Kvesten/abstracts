Возможна чуть-более сложная схема.

Функция а вызывает функцию б, а та в свою очередь вызывает функцию а. Это называется косвенной рекурсией.

При этом получается, что описанная первой функция должна вызывать ещё не описанную.

Чтобы это было возможно требуется использовать прототип функции.

## Рекурсивная обработка массивов.
Посчитать сумму
```c
int sum(int ii, int *a) {
    if (ii==-1) return 0;
    else if (a[ii] > 0) return a[ii] + summa(ii - 1, a);
    else return summa(ii - 1, a);
}

int main() {
    printf("%d", sum(n - 1, a));;
}
```

## Перечисляемые типы

Перечисления(enum) или перечисляемый тип - это тип данных, где любое значение определяется как символьная константа. Объявить перечисления можно с помощью ключегого слова ```enum```

Пример:

```c++
enum Colors {
    COLOR_RED,
    COLOR_GREEN,
    COLOR_BLUE
};

Colors paint = COLOR_RED;
```

Объявление перечеслений не требует выделения память, память выделяется только при определении переменной перечисляемого типа

## Имена перечислений

Идентификаторы перечислений часто начинаются с заглавной буквы. А имена перечислителей вообще состоят только из заглавных букв.

Поскольку перечислители вместе с перечислением находятся в едином пространстве имён, то имена перечислителей не могут повторяться в разных перечислениях.

```c++
enum Colors {
    YELLOW,
    BLACK, // BLACK В ДРУГОМ ЕНУМЕ
    PINK
};

enum Feelings {
    SAD,
    ANGRY,
    BLACK // ОШИБКА
};
```

>*Распространено добавление названия перечисления в качестве префикса к перечислителю*

## Значения перечислителей

Каждому перечислителю автоматически присываивается значение целочисленное значение в зависимости от его позиции в списке перечисления.

По-умолчанию первому перечислителю присваивается 0, а каждому следующему i+1

```c++
enum Colors {
    COLOR_RED, // 0
    COLOR_GREEN, // 1
    COLOR_BLUE // 2
};

Colors paint(COLOR_BLUE);
printf("%d", paint);
```

Можно и самостоятельно определять значения перечеслителей. Они могут быть как положительными, так и отрицательными или вообще иметь аналогичные другим перечислителям значения. 

Любые неопределённые программистом перечислители будут иметь значения на 1 больше, чем прошлое значение, начиная с нуля.


пример:

```c++
enum HttpAnswers {
    NOT_FOUND = 404,
    SUCCESS = 200,
    WUT = 200, // тоже проканает
    IM_TEAPOT, // 201
    ...
}
```

>Замечание! Не рекомендуется присваивать свои значения перечислителям.

>Замечание! Одинаковые значение двум перечислителям присваивают только в случае ОЧЕНЬ веской причины.

## Обработка перечислений
Поскольку значениями перечислителей являются целые числа, то их можно присваивать целочисленным переменным и выводить в консоль как переменные типа int.

```c++
int ans = NOT_FOUND; // 404
printf("%d", ans);
```


Вводить перечислители нельзя! Однако можно привести целое число, а затем используя оператор ```static_cast<T>(var)``` поместить целочисленное значение в перечисляемый тип.

```c++
int inputColor;
cin inputColor;

Colors color = static_cast<Colors>(input_color);
```

Каждый перечисляемый тип считается отдельным типом, поэтому присвоить перечислитель из одного перечисления перечислитель из другого приведёт к ошибке

```c++
Animals animal = COLOR_BLUE; // Compile error
```


## Достоинства перечислений.
Перечисляемые типы полезны для документации кода и улучшения читаемости. 

Например функции возвращают целые числа в качестве кодов ошибок. Как правило для этого используют небольшие отрицательные числа.

Также перечисляемые типы можно использовать при определении набора связанных идентификаторов.

Например в некоторой игре игрок может иметь 1 предмет, но этот предмет может иметь несколько разных типов.

Перечислении не столь безопасны, как может показаться и в некоторых случаях позваляют делать вещи, которые не имеют смысла. 

Например.
```c++
enum Fruits {
    APPLE,
};

enum Weapons {
    SPAS12,
};
int fruit = APPLE;
int spas = SPAS12;

if (fruit == spas) // Сравнили оружие и яблоко и это верно, ведь они оба имеют числ. значение 0. 
```

для решение этой проблемы стандартный с++11 добавили перечисления с областью видимости, которые добавляют перечисления в локальную область видимости. Для этого необходимо добавить ключевое слово класс сразу после ключевого слова enum.

# Структуры